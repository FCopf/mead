{
  "hash": "8fff4c6dc2686778665fb941add8a8dc",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Operadores pipe\"\ndescription: \"Uso de operadores pipe para encadear funções e simplificar fluxos de dados em R.\"\ncategories: [\n          \"Ciência de dados\",\n          \"R\",\n          \"Tidyverse\",\n          \"Transformação de dados\"\n        ]\nimage: \"images/pipe.jpg\"\nexecute:\n  echo: true\n  warning: false\n  include: true\n  message: false\n---\n\n\n\n\nEm R, **operadores pipe** são usados para passar a saída de uma função para a entrada de outra, tornando o código mais legível e conciso. Este tutorial compara o operador pipe nativo `|>` introduzido no R 4.1.0 e o operador `%>%` do pacote `magrittr`.\n\n## Operador Pipe nativo `|>`\n\nO operador pipe nativo `|>` é uma nova adição ao R base. Ele permite escrever código mais limpo e legível ao encadear funções.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Exemplo usando o operador pipe nativo |>\nresultado <- 1:10 |> \n  sum() |>\n  sqrt()\n\nresultado\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7.416198\n```\n\n\n:::\n:::\n\n\n\n\nNeste exemplo, a sequência de 1 a 10 é passada para a função `sum()`, e o resultado é então passado para a função `sqrt()```.\n\nO mesmo resultado é obtido sem o operador pipe por:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresultado <- sqrt(sum(1:10))\n\nresultado\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7.416198\n```\n\n\n:::\n:::\n\n\n\n\n\n## Operador Pipe do pacote magrittr %>%\n\nO operador `%>%` do pacote `magrittr``` tem sido amplamente usado na comunidade R há vários anos. Ele serve ao mesmo propósito que o operador pipe nativo, mas possui alguns recursos adicionais.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(magrittr)\n\n# Exemplo usando o operador pipe do magrittr %>%\nresultado <- 1:10 %>%\n  sum() %>%\n  sqrt()\n\nresultado\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7.416198\n```\n\n\n:::\n:::\n\n\n\n\nEste exemplo alcança o mesmo resultado que o anterior, mas usa o operador `%>%` do pacote `magrittr`.\n\n## Diferenças e Considerações\n\n### Suporte a Placeholder\n\nUma diferença chave é que `%>%` suporta placeholders `(.)`, que podem ser úteis para pipelines mais complexos.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Usando placeholder com %>%\nresultado <- 1:10 %>%\n  sum() %>%\n  { . / 2 } %>%\n  sqrt()\n\nresultado\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.244044\n```\n\n\n:::\n:::\n\n\n\n\nO operador pipe nativo `|>` não suporta placeholders diretamente.\n\nUsando o pipe nativo, a mesma expressão ficaria:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresultado <- 1:10 |>\n  sum() |>\n  (\\(x) x / 2)() |>  # Esta linha é similar à: `(function(x) x / 2)()`\n  sqrt()\n```\n:::\n\n\n\n\nPortanto, torna-se necessário declarar uma função dentro da sequência se comandos.\n\n## Tratamento de Erros e Depuração\n\nO operador `%>%` do magrittr fornece mensagens de erro mais detalhadas e melhores capacidades de depuração. Se você encontrar um erro em um pipeline usando `|>`, a mensagem de erro pode ser menos informativa em comparação com o uso de `%>%`.\n\n## Desempenho\n\nAmbos os operadores pipe têm desempenho semelhante na maioria dos casos. No entanto, `|>` por ser parte do R base, pode ter ligeiras vantagens de desempenho em alguns cenários devido à sua integração com a linguagem principal.\n\n## Quando usar operadores pipe\n\nTanto o operador pipe nativo `|>` quanto o operador `%>%` do magrittr são ferramentas poderosas para escrever código R limpo e legível. A escolha entre eles depende de suas necessidades específicas e preferências. Se você precisa de suporte a placeholders e depuração aprimorada, `%>%` é uma boa escolha. Para uma dependência mais leve e potencialmente melhor desempenho, `|>` é uma opção sólida. A seguir algumas sugestões para a escolha entre os operadores.\n\n1. *Leitura e Legibilidade*: Use operadores pipe quando você deseja aumentar a legibilidade do código. Eles ajudam a encadear operações de forma linear, tornando o fluxo de dados claro e fácil de seguir.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresultado <- dados %>%\n  filter(variavel1 > 10) %>%  # Filtra os dados\n  mutate(nova_variavel = variavel2 * 2) %>%  # insere `nova_variavel` no data frame\n  summarise(media = mean(nova_variavel))  # extrai a média da `nova_variavel`\n```\n:::\n\n\n\n\n2. *Transformações Sequenciais*: Use operadores pipe quando você precisa aplicar uma série de transformações sequenciais nos dados. Eles permitem que você evite a criação de variáveis temporárias.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresultado <- dados |>\n  filter(variavel1 > 10) |>\n  mutate(nova_variavel = variavel2 * 2) |>\n  summarise(media = mean(nova_variavel))\n\n# Sem o operador pipe, esta sequância de códigos poderia ficar:\nres1 <- filter(dados, variável1 > 10)\nres2 <- mutate(res1, nova_variavel = variavel2 * 2)\nresultado <- summarise(res2, media = mean(nova_variavel))\n```\n:::\n\n\n\n\n3. *Consistência de Sintaxe*: Utilize pipes para manter uma sintaxe consistente em todo o seu código, especialmente se você estiver trabalhando em um projeto colaborativo onde a consistência de estilo é importante.\n\n4. *Simplificação de Funções Aninhadas*: Empregue operadores pipe para simplificar a leitura de funções aninhadas, evitando a necessidade de múltiplos parênteses.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresultado <- sqrt(sum(1:10))\n\n# versus\n\nresultado_pipe <- 1:10 |>\n  sum() |>\n  sqrt()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresultado\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7.416198\n```\n\n\n:::\n\n```{.r .cell-code}\nresultado_pipe\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7.416198\n```\n\n\n:::\n:::\n\n\n\n\n5. *Codificação Explorativa e Prototipagem Rápida*: Use pipes durante a exploração de dados e prototipagem rápida, pois eles permitem que você altere e teste rapidamente diferentes transformações.\n\n\n## Quando Não Usar Operadores Pipe\n\n1. *Simplicidade Excessiva*: Evite usar operadores pipe para operações extremamente simples onde o uso de pipes não adiciona clareza. Por exemplo, `sum(1:10)` é mais claro sem o pipe.\n\n2. *Depuração de Código*: Não use pipes se você está tendo dificuldades para depurar uma sequência de operações. Em vez disso, atribua resultados intermediários a variáveis temporárias para inspecioná-los.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npasso1 <- filter(dados, variavel1 > 10)\npasso2 <- mutate(passo1, nova_variavel = variavel2 * 2)\nresultado <- summarise(passo2, media = mean(nova_variavel))\n```\n:::\n\n\n\n\n3. *Operações Complexas com Várias Etapas*: Evite usar pipes em operações muito complexas que envolvem várias etapas interdependentes, onde a clareza do código pode ser comprometida. Por exemplo se você precisa manipular dois data frames independentes e depois uní-los, fazer isso em uma única sequencia de operadores pipe pode tornar o código difícil de interpretar.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Criando exemplos de data frames\ndados1 <- data.frame(\n  categoria = rep(c(\"A\", \"B\", \"C\"), each = 4),\n  variavel1 = rnorm(12, mean = 6, sd = 2)\n)\n\ndados2 <- data.frame(\n  categoria = rep(c(\"A\", \"B\", \"C\"), each = 4),\n  variavel2 = rnorm(12, mean = 10, sd = 5)\n)\n\nlibrary(dplyr)\n# Operações complexas em uma única sequência de operadores pipe\nresultado <- dados1 |>\n  group_by(categoria) |>\n  summarise(media_variavel1 = mean(variavel1)) |>\n  inner_join(\n    dados2 |> \n      group_by(categoria) |> \n      summarise(soma_variavel2 = sum(variavel2)),\n    by = \"categoria\"\n  ) |>\n  mutate(nova_variavel = soma_variavel2 / media_variavel1) |>\n  arrange(desc(nova_variavel))\n\nresultado\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 4\n  categoria media_variavel1 soma_variavel2 nova_variavel\n  <chr>               <dbl>          <dbl>         <dbl>\n1 A                    5.79           27.6          4.77\n2 C                    5.41           25.4          4.70\n3 B                    5.74           24.6          4.28\n```\n\n\n:::\n:::\n\n\n\n\nO exemplo acima pode ser reescrito de forma que cada etapa tenha uma leitura mais clara.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Passo 1: Filtrar e resumir dados1\nresumo_dados1 <- dados1 |>\n  group_by(categoria) |>\n  summarise(media_variavel1 = mean(variavel1))\n\n# Passo 2: Filtrar e resumir dados2\nresumo_dados2 <- dados2 |>\n  group_by(categoria) |>\n  summarise(soma_variavel2 = sum(variavel2))\n\n# Passo 3: Unir os resultados dos dois data frames\nresultado_unido <- inner_join(resumo_dados1, \n                                     resumo_dados2, \n                                     by = \"categoria\")  |>  \n  mutate(nova_variavel = soma_variavel2 / media_variavel1) |>\n  arrange(desc(nova_variavel))\n\nresultado_unido\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 4\n  categoria media_variavel1 soma_variavel2 nova_variavel\n  <chr>               <dbl>          <dbl>         <dbl>\n1 A                    5.79           27.6          4.77\n2 C                    5.41           25.4          4.70\n3 B                    5.74           24.6          4.28\n```\n\n\n:::\n:::\n\n\n\n\nEmbora o código tenha ficado mais longo, fica também mais simples de ser inspecionado.\n\n4. *Desempenho Crítico*: Se você está preocupado com o desempenho crítico e a eficiência, pode ser melhor evitar pipes, já que eles podem adicionar alguma sobrecarga.\n\n5. *Ambiguidade de Funções*: Evite pipes se o uso deles torna a ordem das operações ou a origem dos dados ambígua. Certifique-se de que a sequência de operações é clara e lógica.\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}